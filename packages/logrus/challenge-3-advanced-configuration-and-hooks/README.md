# Challenge 3: Advanced Configuration & Hooks

Elevate your logging strategy by building a **Task Scheduler** that uses a custom `logrus` hook to send logs to multiple destinations based on their severity. This challenge introduces professional logging patterns used in production systems.

## Challenge Requirements

Create a Go application that simulates a task scheduler and configures a logger with a custom hook.

1. **Dual Logging Setup**: Configure a `logrus` logger that:

   * Writes all general logs (`Info` level and above) to the console (`os.Stdout`).
   * Uses a **custom hook** to *also* write critical logs (`Error` and `Fatal` levels) to a separate destination in a different format.

2. **Create a Custom `ErrorHook`**: Implement the `logrus.Hook` interface to create a hook that:

   * Triggers only for `ErrorLevel` and `FatalLevel` entries.
   * Formats the log entry it receives into `JSON`.
   * Writes the formatted JSON log to its own dedicated output (for this challenge, a separate `io.Writer`).

3. **Simulate a Task Scheduler**: Implement a `runTaskScheduler` function that logs the status of several simulated tasks with different outcomes (success, warning, and failure).

## How It Should Work

Your application will have two distinct log streams. The console will show a human-readable feed of all task activities. Simultaneously, a separate, machine-readable `JSON` stream will be generated containing *only* the critical errors, perfect for ingestion by an external monitoring system.

---

### Sample Output

When you run the application, you will see two different outputs.

**1. Console Output (Text Format):**
This stream contains all logs from `Info` level and up, formatted for easy reading.

```text
INFO[0000] Starting task scheduler...
INFO[0000] Starting task: Process daily reports
INFO[0000] Task 'Process daily reports' completed successfully  task_duration=250ms
WARN[0000] Task 'Sync user data': upstream API is slow      task_id=sync-001
ERRO[0000] Task 'Backup database' failed: connection timed out  retry_attempt=3
```

**2. Error Log Output (JSON Format):**
This stream is generated by your custom hook and only contains the error-level log, formatted as structured JSON.

```json
{"level":"error","msg":"Task 'Backup database' failed: connection timed out","retry_attempt":3,"time":"2025-10-03T03:15:00+05:30"}
```

---

## Implementation Requirements

### Logger Configuration (main function)

* Create a new logger instance using `logrus.New()` instead of using the global logger.
* Set the main logger's formatter to `logrus.TextFormatter`.
* Set the main logger's output to `os.Stdout`.
* Instantiate your custom `ErrorHook`, providing it with a separate `io.Writer` (e.g., a `bytes.Buffer` for testing or a file in real runs).
* Add the hook to the logger instance using `logger.AddHook()`.
* `runTaskScheduler` should accept the configured `*logrus.Logger` as an argument and emit the required logs.

#### Imports & Writers (add to Logger Configuration)

Make sure the implementation imports these packages (example):

```go
import (
    "bytes"
    "io"
    "os"

    "github.com/sirupsen/logrus"
)
```

When using a file writer in production (for alerts or tests), open it with safe flags:

```go
f, err := os.OpenFile("alerts.log", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
if err != nil { /* handle error */ }
defer f.Close()
```

Tests will often use `bytes.Buffer` instead of files; design your hook to accept an `io.Writer` so tests can inject buffers.

#### Exact logger setup to use (paste into your main)

```go
logger := logrus.New()
logger.SetFormatter(&logrus.TextFormatter{}) // console-friendly
logger.SetOutput(os.Stdout)

// Hook writer: for tests use bytes.Buffer, for real runs open a file
var hookWriter io.Writer = &bytes.Buffer{} // tests will assert on this

hook := &ErrorHook{
    Out:       hookWriter,
    Formatter: &logrus.JSONFormatter{},
}
logger.AddHook(hook)

// runTaskScheduler should accept *logrus.Logger
runTaskScheduler(logger)
```

---

### ErrorHook Implementation

Create a struct that implements `logrus.Hook`. The hook must:

* Implement `Levels() []logrus.Level` and return only `logrus.ErrorLevel` and `logrus.FatalLevel`.
* Implement `Fire(*logrus.Entry) error` to:

  * Format the entry using `logrus.JSONFormatter` (or the provided `Formatter`).
  * Write a single JSON object (with a trailing newline) to the hook's `io.Writer`.

#### ErrorHook â€” minimal, exact contract & example

The hook must implement `logrus.Hook` exactly as below (synchronous write is fine for tests):

```go
type ErrorHook struct {
    Out       io.Writer
    Formatter logrus.Formatter // expected: &logrus.JSONFormatter{}
}

func (h *ErrorHook) Levels() []logrus.Level {
    return []logrus.Level{logrus.ErrorLevel, logrus.FatalLevel}
}

func (h *ErrorHook) Fire(entry *logrus.Entry) error {
    // Use the provided formatter to render a single JSON object.
    b, err := h.Formatter.Format(entry)
    if err != nil {
        return err
    }
    // Ensure a trailing newline so file readers treat each entry as a separate line.
    if _, err := h.Out.Write(append(b, '\n')); err != nil {
        return err
    }
    return nil
}
```

Notes:

* Use `&logrus.JSONFormatter{}` for `Formatter`.
* Tests expect one JSON object per error entry (newline-separated).
* The hook should be synchronous in tests (no buffering) unless you explicitly coordinate flushing in tests.

---

### Main Logic (`runTaskScheduler` function)

`runTaskScheduler(logger *logrus.Logger)` should:

* Log an Info message for a successful task (include `task_duration` field).

  * Exact message format (tests expect): `Task '<NAME>' completed successfully`
  * Example field: `task_duration="250ms"`
* Log a Warn message for a potential issue (include `task_id` field).

  * Message must contain the task name (no rigid exact-match requirement here).
* Log an Error message for a failed task (include `retry_attempt` field).

  * Exact message format (tests expect): `Task '<NAME>' failed: <reason>`
  * Field: `retry_attempt` (integer)

Example logging calls:

```go
logger.WithField("task_duration", "250ms").Infof("Task '%s' completed successfully", "Process daily reports")
logger.WithField("task_id", "sync-001").Warnf("Task '%s': upstream API is slow", "Sync user data")
logger.WithField("retry_attempt", 3).Errorf("Task '%s' failed: %s", "Backup database", "connection timed out")
```

---

## Testing Requirements

Your solution must pass tests that verify:

* The main logger writes Info, Warn, and Error logs to its output in Text format.
* The ErrorHook's output contains **only** the Error (and Fatal) logs.
* The ErrorHook's output is formatted correctly as a single JSON object per error entry (newline terminated).
* The fields (e.g., `retry_attempt`) are present in both the main log output and the hook's output.

#### Testing hints (must-read)

Tests will assert on exact field names and message text. Use these keys and messages exactly:

* **Info success message**

  * msg: `Task '<NAME>' completed successfully`
  * field: `task_duration` (e.g. `250ms`)
* **Warn message**

  * msg contains: `Task '<NAME>'`
  * field: `task_id` (e.g. `sync-001`)
* **Error message**

  * msg: `Task '<NAME>' failed: <reason>`
  * field: `retry_attempt` (integer)

The ErrorHook's output must contain:

* A single JSON object per error entry.
* The same fields present in the main log (e.g., `retry_attempt`).
* A trailing newline after each JSON object.

---

## Dependencies

Dependencies:

* `github.com/sirupsen/logrus`

Install with:

```sh
go get github.com/sirupsen/logrus
```

> Note: tests typically inject `bytes.Buffer` instances and assert synchronously on the hook writer. Design your hook so its output writer is injectable and writes synchronously for tests.
---