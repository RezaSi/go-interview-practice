---
description: Generate comprehensive test suites for Go package challenges with table-driven tests and edge cases
globs: ["packages/**/*_test.go"]
alwaysApply: false
---

# Package Challenge Test Generator

Generate comprehensive, robust test suites for Go package challenges following established patterns.

## Test File Structure Requirements

### Standard Test Template:
```go
package main

import (
	"bytes"
	"os"
	"strings"
	"testing"
	// Add package-specific imports
)

// Helper function to execute command and capture output (for CLI packages)
func executeCommand(root *{PackageType}, args ...string) (output string, err error) {
	buf := new(bytes.Buffer)
	root.SetOut(buf)
	root.SetErr(buf)
	root.SetArgs(args)

	err = root.Execute()
	return buf.String(), err
}

// Helper function for HTTP testing (for web packages)
func performRequest(r http.Handler, method, path string, body io.Reader) *httptest.ResponseRecorder {
	req, _ := http.NewRequest(method, path, body)
	w := httptest.NewRecorder()
	r.ServeHTTP(w, req)
	return w
}
```

## Test Categories Required

### 1. Functionality Tests
Test core features and business logic:
```go
func Test{FeatureName}(t *testing.T) {
	tests := []struct {
		name     string
		input    {InputType}
		expected {OutputType}
		wantErr  bool
	}{
		{
			name:     "valid input",
			input:    {ValidInput},
			expected: {ExpectedOutput},
			wantErr:  false,
		},
		{
			name:     "edge case",
			input:    {EdgeCaseInput},
			expected: {EdgeCaseOutput},
			wantErr:  false,
		},
		{
			name:     "error case",
			input:    {InvalidInput},
			expected: {ZeroValue},
			wantErr:  true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := {FunctionUnderTest}(tt.input)
			
			if (err != nil) != tt.wantErr {
				t.Errorf("Expected error: %v, got: %v", tt.wantErr, err)
				return
			}
			
			if !tt.wantErr && result != tt.expected {
				t.Errorf("Expected: %v, got: %v", tt.expected, result)
			}
		})
	}
}
```

### 2. Command Structure Tests (for CLI packages)
```go
func TestCommandStructure(t *testing.T) {
	commands := rootCmd.Commands()
	
	commandNames := make([]string, len(commands))
	for i, cmd := range commands {
		commandNames[i] = cmd.Name()
	}
	
	expectedCommands := []string{"{cmd1}", "{cmd2}", "{cmd3}"}
	
	for _, expected := range expectedCommands {
		found := false
		for _, name := range commandNames {
			if name == expected {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Expected command '%s' not found. Available: %v", expected, commandNames)
		}
	}
}
```

### 3. Metadata Tests
```go
func Test{Component}Metadata(t *testing.T) {
	if {component}.{Property} != "{ExpectedValue}" {
		t.Errorf("Expected {property} to be '{ExpectedValue}', got '%s'", {component}.{Property})
	}
}
```

### 4. Output Format Tests
```go
func Test{Command}Output(t *testing.T) {
	output, err := executeCommand(rootCmd, "{command}")
	if err != nil {
		t.Fatalf("{Command} command failed: %v", err)
	}

	expectedStrings := []string{
		"{expected_string_1}",
		"{expected_string_2}",
	}

	for _, expected := range expectedStrings {
		if !strings.Contains(output, expected) {
			t.Errorf("Output missing '%s'\nGot: %s", expected, output)
		}
	}
}
```

### 5. HTTP Tests (for web packages)
```go
func Test{Endpoint}(t *testing.T) {
	tests := []struct {
		name           string
		method         string
		url            string
		body           string
		expectedStatus int
		expectedBody   string
	}{
		{
			name:           "successful request",
			method:         "GET",
			url:            "/api/test",
			body:           "",
			expectedStatus: 200,
			expectedBody:   `{"status":"success"}`,
		},
		{
			name:           "invalid request",
			method:         "POST",
			url:            "/api/test",
			body:           "invalid json",
			expectedStatus: 400,
			expectedBody:   "Bad Request",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			w := performRequest(router, tt.method, tt.url, strings.NewReader(tt.body))
			
			if w.Code != tt.expectedStatus {
				t.Errorf("Expected status %d, got %d", tt.expectedStatus, w.Code)
			}
			
			if !strings.Contains(w.Body.String(), tt.expectedBody) {
				t.Errorf("Expected body to contain '%s', got: %s", tt.expectedBody, w.Body.String())
			}
		})
	}
}
```

### 6. Database Tests (for ORM packages)
```go
func Test{DatabaseOperation}(t *testing.T) {
	// Setup test database
	db := setupTestDB(t)
	defer teardownTestDB(t, db)
	
	tests := []struct {
		name    string
		setup   func()
		input   {InputType}
		want    {OutputType}
		wantErr bool
	}{
		{
			name: "successful operation",
			setup: func() {
				// Setup test data
			},
			input:   {ValidInput},
			want:    {ExpectedOutput},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.setup != nil {
				tt.setup()
			}
			
			result, err := {DatabaseFunction}(db, tt.input)
			
			if (err != nil) != tt.wantErr {
				t.Errorf("Expected error: %v, got: %v", tt.wantErr, err)
				return
			}
			
			if !reflect.DeepEqual(result, tt.want) {
				t.Errorf("Expected: %+v, got: %+v", tt.want, result)
			}
		})
	}
}
```

## Test Coverage Requirements

### Must Test:
- ✅ All public functions and methods
- ✅ Command structure and hierarchy (CLI)
- ✅ HTTP endpoints and status codes (Web)
- ✅ Database operations and transactions (ORM)
- ✅ Error conditions and edge cases
- ✅ Input validation and sanitization
- ✅ Output format and content
- ✅ Configuration and initialization
- ✅ Help text and documentation

### Edge Cases to Include:
- Empty inputs
- Nil values
- Maximum/minimum values
- Invalid formats
- Network failures (for web/database)
- File system errors (for CLI)
- Concurrent access (where applicable)

## Test Naming Conventions:
- `Test{FeatureName}` - Main functionality tests
- `Test{Command}Command` - CLI command tests
- `Test{Endpoint}Handler` - HTTP handler tests
- `Test{Model}CRUD` - Database operation tests
- `Test{Component}Metadata` - Structure validation tests
- `TestMainFunction` - Main execution tests

## Helper Functions Standards:
- Always include command execution helpers for CLI packages
- Include HTTP request helpers for web packages
- Include database setup/teardown for ORM packages
- Use consistent error handling patterns
- Provide clear, descriptive test failure messages

## Test Organization:
1. Group related tests together
2. Use descriptive test names
3. Include both positive and negative test cases
4. Test boundary conditions
5. Verify error messages are helpful
6. Ensure tests are independent and can run in any order